# 命令行深度指南

> 100 天认知提升计划 | Day 2

---

## 目录

- [第一部分：Shell 生态与选择](#第一部分shell-生态与选择)
  - [Shell 概述与对比](#shell-概述与对比)
  - [POSIX 兼容性](#posix-兼容性)
  - [Windows 终端生态](#windows-终端生态)
- [第二部分：命令行执行原理](#第二部分命令行执行原理)
  - [执行流程](#执行流程)
  - [会话与进程组](#会话与进程组)
  - [环境变量与缓存](#环境变量与缓存)
- [第三部分：富媒体终端输出](#第三部分富媒体终端输出)
  - [终端控制序列](#终端控制序列)
  - [图片与视频显示](#图片与视频显示)
- [第四部分：实践与思考](#第四部分实践与思考)

---

## 第一部分：Shell 生态与选择

### Shell 概述与对比

**什么是 Shell**

Shell 是用户与操作系统内核之间的命令解释器，它读取用户输入的命令并执行。从系统角度看，Shell 只是一个普通的用户态程序。

| Shell | 发布年份 | 特点 | 适用场景 |
|-------|---------|------|---------|
| **sh** | 1977 | POSIX 标准，最基础 | 兼容性优先的脚本 |
| **bash** | 1989 | GNU Project，功能丰富 | Linux 默认 shell |
| **zsh** | 1990 | 强大的补全和主题 | 交互式使用首选 |
| **fish** | 2005 | 开箱即用，自动补全 | 新手友好 |
| **nu** | 2019 | 结构化数据 | 现代数据流处理 |
| **powershell** | 2006 | 面向对象，.NET 集成 | Windows 管理 |

---

### 功能对比

**补全能力**

| 特性 | bash | zsh | fish | nushell |
|------|------|-----|------|---------|
| 命令补全 | ✅ | ✅ | ✅ | ✅ |
| 命令参数补全 | ❌ | ✅ | ✅ | ✅ |
| 模糊匹配 | ❌ | ✅ | ✅ | ✅ |
| 命令预览 | ❌ | ❌ | ❌ | ✅ |
| 语法高亮 | ❌ | ✅ | ✅ | ✅ |

**Zsh 独有特性**

```bash
# 强大的通配符
ls *.txt          # 常规通配符
ls **/*.zsh       # 递归匹配
ls *(.)           # 只匹配普通文件
ls *(/)           # 只匹配目录
ls *(om[1,5])     # 匹配最近修改的5个文件

# 右侧补全（在命令末尾也能补全）
vim ~<Tab>        # 从路径开头补全
cd config/<Tab>   # 从中间补全

# 智能跳转
foo=/very/long/path
cd foo<Tab>       # 展开为 cd /very/long/path
```

**Bash vs Zsh 选择建议**

| 场景 | 推荐 |
|------|------|
| 服务器脚本 | bash（兼容性） |
| 个人开发环境 | zsh + Oh My Zsh |
| 写通用脚本 | sh（最小公分母） |
| 数据处理管道 | nushell |
| Windows 生态 | PowerShell 7+ |

---

### POSIX 兼容性

**POSIX sh 标准**

为最大兼容性，脚本应遵循 POSIX sh 规范：

| 特性 | POSIX | 非 POSIX |
|------|-------|-----------|
| `[[` 测试 | ❌ | bash/zsh |
| `((` 算术 | ❌ | bash/zsh |
| 数组 | ❌ | bash/zsh |
| 进程替换 `<()` | ❌ | bash/zsh |
| 函数内 `local` | ✅ | - |

**shebang 最佳实践**

```bash
#!/bin/sh          # 最兼容，使用 POSIX 语法
#!/usr/bin/env sh  # 更好的可移植性

#!/bin/bash        # 需要 bash 特性时
#!/usr/bin/env bash

#!/bin/zsh
#!/usr/bin/env zsh

#!/usr/bin/env bash
set -euo pipefail  # 现代脚本推荐（bash 4+）
```

---

### Windows 终端生态

**Windows 终端演进**

| 时代 | 终端 | Shell |
|------|------|-------|
| 传统 | cmd.exe | 批处理 |
| PowerShell 5.1 | Console | PowerShell（仅 .NET Framework） |
| 现代 | Windows Terminal | PowerShell 7+ / WSL / Git Bash |

**Windows Terminal 特性**

```json
// profiles.json 关键配置
{
    "profiles": {
        "defaults": {
            "fontFace": "Cascadia Code",
            "fontSize": 11,
            "cursorShape": "filledBox",
            "acrylicOpacity": 0.8,           // 毛玻璃效果
            "useAcrylic": true,
            "colorScheme": "One Half Dark"
        },
        "list": [
            {
                "guid": "{574e775e-4f2a-5b96-ac1e-a2962a402336}",
                "name": "PowerShell",
                "source": "Windows.Terminal.PowershellCore"
            },
            {
                "guid": "{2c4de342-38b7-51cf-b940-2309a097f518}",
                "name": "Ubuntu",
                "source": "Windows.Terminal.Wsl"
            }
        ]
    }
}
```

**WSL 2 架构**

```
┌─────────────────────────────────────────────────────────┐
│              Windows Terminal / ConHost                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
│  │  PowerShell │    │    WSL      │    │   Git Bash  │ │
│  │     7+      │    │    (Ubuntu) │    │             │ │ │
│  └──────┬──────┘    └──────┬──────┘    └─────────────┘ │
│         │                  │                            │
│         │           ┌──────▼──────┐                      │
│         │           │  WSL 2 LXSS │                      │
│         │           │  VM (轻量)   │                      │
│         │           └──────┬──────┘                      │
│         │                  │                            │
│         │           ┌──────▼──────┐                      │
│         │           │ Linux Kernel │                      │
│         │           │  (真实内核)  │                      │
│         │           └─────────────┘                      │
│         │                                               │
│  ┌──────▼──────────────────────────────────────────────▼──┐
│  │           Windows NT Kernel                            │
│  │    (计划任务、文件系统、网络、硬件访问)                  │
│  └────────────────────────────────────────────────────────┘
└─────────────────────────────────────────────────────────┘
```

**跨平台 Shell 体验**

| 特性 | Git Bash | WSL 1 | WSL 2 |
|------|----------|-------|-------|
| 文件系统性能 | 🟡 中等 | 🔴 慢 | 🟢 快 |
| 系统调用兼容 | 🔴 差 | 🟡 部分 | 🟢 完整 |
| Docker 支持 | ❌ | ❌ | ✅ |
| 磁盘占用 | 🟢 小 | 🟢 小 | 🔴 大（2GB+）|

---

## 第二部分：命令行执行原理

### 执行流程

**完整执行链路**

```
用户输入 → Shell 解析 → 展开 → 查找命令 → 执行 → 返回状态
   │           │         │         │         │         │
   ▼           ▼         ▼         ▼         ▼         ▼
  键盘    词法分析   通配符/   $PATH    fork+exec  exit code
            语法分析   变量展开   定位      execve     $?
                     命令替换
                     路径展开
```

**步骤详解**

```bash
# 示例命令：cat $(which ls) | grep ^/

# 1. 词法分析 - 分割为 token
tokens: [cat, $(which ls), |, grep, ^/]

# 2. 语法分析 - 构建语法树
pipe
├─ left: cat $(which ls)
└─ right: grep ^/

# 3. 展开
#    - 命令替换: $(which ls) → /usr/bin/ls
#    - 通配符: ^/ → ^/（grep 正则，不是 glob）
expanded: [cat, /usr/bin/ls, |, grep, ^/]

# 4. 建立管道
pipe(fd[0], fd[1])

# 5. fork + exec
#    父进程 fork 子进程1: execve("/usr/bin/cat", ["/usr/bin/ls"])
#    父进程 fork 子进程2: execve("/usr/bin/grep", ["^/"])

# 6. 等待并获取退出状态
waitpid() → $?
```

---

### 会话与进程组

**终端会话层次结构**

```
┌─────────────────────────────────────────────────────────┐
│                    Login Shell                          │
│                   (PID 1234, PGID 1234)                 │
│                   Session Leader                        │
│                    SID: 1234                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌───────────────┐  ┌───────────────┐  ┌─────────────┐│
│  │  vim (PGID A) │  │  npm (PGID B) │  │  python    ││
│  │  PID 2000     │  │  PID 3000     │  │  REPL      ││
│  └───────────────┘  └───────────────┘  └─────────────┘│
│                                                         │
│  每个进程组 = 一个前台/后台任务                          │
└─────────────────────────────────────────────────────────┘
```

**进程组与会话概念**

```bash
# 查看进程关系
ps -o pid,ppid,pgid,sid,comm -C zsh

# 输出示例
  PID  PPID  PGID   SID COMMAND
 1234  1233  1234  1234 zsh        # Session Leader
 5678  1234  5678  1234 vim        # 新进程组（前台）
 9012  1234  9012  1234 npm        # 新进程组（后台）
```

| 术语 | 说明 | 典型操作 |
|------|------|----------|
| **Session（会话）** | 一个登录 shell 创建的会话 | 登录时创建 |
| **Session Leader** | 创建会话的进程 | 通常是登录 shell |
| **Process Group（进程组）** | 一组相关进程 | 管道命令、job control |
| **Foreground Group** | 能接收终端输入的进程组 | 当前运行的命令 |
| **Background Group** | 不能接收终端输入的进程组 | `&` 启动、`bg` 命令 |

**Job Control 实践**

```bash
# 启动后台任务
npm run dev &
# 输出: [1] 5678

# 查看后台任务
jobs
# 输出: [1]+  Running  npm run dev

# 切换到前台
fg %1

# 挂起当前前台任务（Ctrl+Z）
# 输出: [1]+  Stopped  npm run dev

# 后台继续
bg %1

# 任务控制信号
SIGTSTP  (Ctrl+Z)  → 终端停止信号
SIGCONT  (bg命令)  → 继续执行
SIGTTIN  (后台读)  → 后台进程尝试读取终端
SIGTTOU  (后台写)  → 后台进程尝试写入终端
```

---

### 环境变量与缓存

**Shell 会话缓存机制**

```bash
# 1. 哈希表缓存（命令路径缓存）
type ls        # 输出: ls is hashed (/usr/bin/ls)
hash -r        # 清除哈希表
hash           # 查看所有缓存
# 输出:
# builtins: (48个内置命令)
# commands: (78个缓存路径)

# 2. 历史缓存
HISTSIZE=10000              # 内存中保存的命令数
HISTFILESIZE=20000          # 文件中保存的命令数
HISTCONTROL=ignoredups:erasedups  # 去重策略

# 3. 目录栈缓存
dirs -v                      # 查看目录栈
pushd /tmp                   # 压入目录
popd                         # 弹出目录

# 4. 变量缓存（本地变量 vs 环境变量）
local_var="local"            # 仅当前 shell
export GLOBAL_VAR="global"   # 导出到子进程
readonly FIXED="immutable"   # 只读变量
```

**会话隔离机制**

```
┌─────────────────────────────────────────────────────┐
│                   Session A                         │
│  ┌────────────┐      ┌──────────────────────────┐   │
│  │ Parent     │───▶  │ Environment (exported)   │   │
│  │ Shell      │      │ - PATH                   │   │
│  │            │      │ - HOME                   │   │
│  │ Local:     │      │ - USER                   │   │
│  │ - var_a    │      └──────────┬───────────────┘   │
│  └────────────┘             │ 继承                   │
│                             ▼                        │
│                      ┌─────────────┐                │
│                      │ Child       │                │
│                      │ Shell       │                │
│                      │ - var_a ✗   │  （不继承本地变量）│
│                      │ - PATH ✓    │  （继承环境变量）│
│                      └─────────────┘                │
└─────────────────────────────────────────────────────┘

          另一个 Session（完全独立）
┌─────────────────────────────────────────────────────┐
│                   Session B                         │
│           (A 的环境变量对 B 不可见)                   │
└─────────────────────────────────────────────────────┘
```

**持久化配置**

```bash
# 配置文件加载顺序（以 zsh 为例）

# 1. 全局配置
/etc/zsh/zshenv        # 所有用户，所有模式
/etc/zsh/zprofile      # 所有用户，login shell
/etc/zsh/zshrc         # 所有用户，interactive shell

# 2. 用户配置
~/.zshenv              # 当前用户，所有模式
~/.zprofile            # 当前用户，login shell
~/.zshrc               # 当前用户，interactive shell
~/.zlogin              # 当前用户，login shell 结尾
~/.zlogout             # 当前用户，login shell 退出

# 加载优先级：
zshenv → zprofile → zshrc → zlogin → [运行] → zlogout
```

---

## 第三部分：富媒体终端输出

### 终端控制序列

**ANSI 转义序列**

终端通过 ANSI 转义序列支持颜色、光标控制等功能：

```bash
# 基本格式: \033[<参数>m
# 也可以用: \e[<参数>m 或 \x1b[<参数>m

# 颜色代码
# 前景色: 30-37, 背景色: 40-47
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
RESET='\033[0m'

echo -e "${RED}错误信息${RESET}"
echo -e "${GREEN}成功${RESET}"

# 256 色模式
echo -e "\033[38;5;208m橙色文字\033[0m"  # 前景色
echo -e "\033[48;5;208m橙色背景\033[0m"  # 背景色

# RGB 模式（需要支持真彩色的终端）
echo -e "\033[38;2;255;100;50mRGB颜色\033[0m"

# 光标控制
clear          # 清屏 = \033[2J
echo -e "\033[10;20H"  # 移动光标到第10行第20列
echo -e "\033[?25l"    # 隐藏光标
echo -e "\033[?25h"    # 显示光标

# 屏幕缓冲区操作
echo -e "\033[?1049h"  # 切换到备用缓冲区
echo -e "\033[?1049l"  # 切换回主缓冲区（用于程序退出后恢复）
```

**终端能力查询（terminfo）**

```bash
# 检查终端能力
tput colors        # 支持的颜色数
tput cols          # 终端宽度
tput lines         # 终端高度
tput setaf 1       # 设置前景色为红色
tput bold          # 粗体
tput sgr0          # 重置所有属性

# 使用 terminfo 编写可移植代码
if [ "$(tput colors)" -ge 256 ]; then
    # 使用 256 色
    color=$(tput setaf 208)
else
    # 回退到基本颜色
    color=$(tput setaf 3)
fi
```

---

### 图片与视频显示

**终端图片渲染原理**

传统终端是纯文本的，图片显示需要通过"字符画"或"六进制转储"实现。

```
┌─────────────────────────────────────────────────────────┐
│                    图片渲染方式                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. ASCII Art  ──▪  字符近似                            │
│     @@@@                                                 │
│     @..@                                                 │
│                                                         │
│  2. ANSI Color  ──▪  半色块（█▓▒░）                     │
│     █████                                              │
│     ▓▓▓▓▓                                              │
│                                                         │
│  3. iTerm2/Kitty Protocol  ──▪  真正的图片渲染         │
│     通过专用协议传输图片数据                            │
│                                                         │
│  4. Sixel  ──▪  位图图形编码                           │
│     通过转义序列发送像素数据                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**终端图片工具对比**

| 工具 | 协议 | 终端要求 | 质量损失 |
|------|------|---------|----------|
| **imgcat** (iTerm2) | iTerm2 Proprietary | iTerm2 | 无 |
| **kitty +kitten** | kitty Protocol | kitty | 无 |
| **chafa** | ANSI/Sixel | 通用 | 高 |
| **viu** | Kitty/iTerm2/sixel | 多终端 | 无/中 |
| **timg** | ANSI/kitty | 多终端 | 中 |
| **lsix** | Sixel | 支持 Sixel | 低 |
| **termvis** | ASCII/ANSI | 通用 | 极高 |

**实践示例**

```bash
# 1. chafa - 通用终端图片查看器
brew install chafa
chafa image.png                     # 自动模式
chafa --format symbols image.png   # 符号模式
chafa --format ansi image.png      # ANSI 模式
cat image.png | chafa --fill blocks  # 管道输入

# 2. kitty +icat
kitty +kitten icat image.png        # 完整图片质量
kitty +kitten icat --align left image.png  # 左对齐

# 3. iTerm2 imgcat
brew install imgcat
imgcat image.jpg

# 4. viu - Rust 编写，支持多种协议
brew install viu
viu image.png
viu -s image.png  # 简单模式（字符画）
cat image.png | viu -  # 管道支持

# 5. lsix - 依赖 Sixel
brew install lsix
lsix *.png  # 类似 ls，但显示缩略图
```

**iTerm2 图片协议示例**

```
ESC ] 1337 ; File = [参数] : base64数据 BEL

参数包括:
- name=文件名
- size=宽x高
- inline=1 (显示) 或 0 (不显示)
- width=宽度 (auto/像素数/百分比)
- height=高度
- preserveAspectRatio=1/0
```

**终端视频播放**

传统终端无法直接播放视频，但可以通过以下方式模拟：

```bash
# 1. ffmpeg + ASCII 转换
ffmpeg -i video.mp4 -vf "scale=80:40" -f image2pipe -vcodec ppm - | \
  convert -delay 5 -loop 0 - video.gif

# 2. aa (ASCII Animation) - VLC 内置
vlc --vout aa video.mp4

# 3. mpv + libcaca (彩色 ASCII)
mpv --vo=caca video.mp4

# 4. timg - 终端动图/视频支持
timg -U video.mp4  # -U 逐帧显示

# 5. terminalizer - 录制终端会话
npm install -g terminalizer
terminalizer record session
terminalizer play session  # 回放
```

**支持富媒体的现代终端**

| 终端 | 图片协议 | 视频支持 | 超链接 |
|------|---------|---------|--------|
| **iTerm2** | ✅ Proprietary | ❌ | ✅ |
| **kitty** | ✅ Native | ❌ | ✅ |
| **WezTerm** | ✅ | ❌ | ✅ |
| **Alacritty** | ❌ | ❌ | ❌ |
| **Windows Terminal** | ❌ | ❌ | ✅ (部分) |

**超链接协议（Hyperlink）**

```bash
# 在终端中创建可点击链接
echo '\e]8;;https://example.com\e\\Click me\e]8;;\e\\'

# 带文字的链接
echo '\e]8;;https://github.com/user/repo\e\\GitHub Repo\e]8;;\e\\'
```

---

## 第四部分：实践与思考

### 实践记录

**必知必会工具清单**

- [ ] **文本处理三剑客**: `grep` / `sed` / `awk`
- [ ] **JSON 处理**: `jq` / `fx`
- [ ] **现代搜索**: `ripgrep` / `fd` / `fzf`
- [ ] **HTTP 调试**: `curl` / `httpie` / `mitmproxy`
- [ ] **性能分析**: `htop` / `btop` / `perf` / `strace`
- [ ] **网络工具**: `dig` / `mtr` / `tcpdump` / `ngrep`
- [ ] **Git 高级**: `git-worktree` / `git-bisect` / `git-reflog`
- [ ] **终端复用**: `zellij` / `tmux`
- [ ] **文件监控**: `fswatch` / `entr`
- [ ] **并行执行**: `parallel` / `xargs -P`

**Shell 配置优化**

- [ ] 配置 Oh My Zsh + Powerlevel10k 主题
- [ ] 设置合理的 `HISTSIZE` 和 `HISTCONTROL`
- [ ] 配置 `fzf` 的 Ctrl+R/Ctrl+T 绑定
- [ ] 设置常用别名（`la`, `ll`, `gs`, `gd`）
- [ ] 配置 `direnv` 自动加载环境变量

**终端增强**

- [ ] 安装 `exa` 或 `eza` 替代 `ls`
- [ ] 安装 `bat` 替代 `cat`
- [ ] 安装 `ripgrep` 替代 `grep`
- [ ] 安装 `fd` 替代 `find`
- [ ] 配置 `starship` 提示符

---

### 疑问与思考

**已解答**

1. ✅ bash/zsh/fish 的核心区别是什么？
   - bash：兼容性最好，服务器标配
   - zsh：功能最强，交互体验最佳
   - fish：开箱即用，但非 POSIX

2. ✅ 命令行的"会话"是如何定义的？
   - Session = 进程组集合 = 一个登录周期
   - Session Leader 控制终端信号分发
   - 子进程默认在同一会话中

3. ✅ shell 如何缓存命令路径？
   - 哈希表（`hash` 命令管理）
   - PATH 顺序查找后缓存结果
   - 新安装程序需要 `hash -r` 刷新

4. ✅ 终端如何显示图片？
   - ANSI 色块模拟（chafa）
   - 专用协议（iTerm2/kitty）
   - Sixel 编码（部分终端支持）

**待探索**

5. ❓ 如何编写一个能在终端显示进度条的 CLI 工具？
6. ❓ TUI（Terminal UI）框架如何工作？（ncurses/bubbletea）
7. ❓ Windows Terminal 的 GPU 加速渲染原理是什么？
8. ❓ 如何实现跨平台的 shell 配置管理？（dotfiles 跨平台策略）

---

*更新日期：2026-02-11*
